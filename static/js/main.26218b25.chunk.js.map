{"version":3,"sources":["config/index.ts","redux/book/utils.ts","containers/Loader/index.tsx","containers/Loader/Loader.tsx","router/index.tsx","redux/store.ts","redux/book/reducers.ts","services/userService.ts","redux/book/selectors.ts","redux/book/sagas.ts","redux/book/actions.ts","containers/App/index.tsx","containers/App/App.tsx","serviceWorker.ts","index.tsx"],"names":["countries","batchSize","catalogueSize","mapConfigToState","reduce","acc","country","appendUsersPage","stateUsers","incomingUsers","reset","length","getNextDisplayedPage","loadedPage","displayedPage","mapReduxToServiceCountries","Object","entries","push","getNextLoadedPage","currentLoadedPage","isNextLoadedPageValid","nextLoadedPage","maxPage","Loader","className","AddressBook","React","lazy","Settings","paths","main","settings","AppRouter","Suspense","fallback","exact","path","to","sagaMiddleware","createSagaMiddleware","store","createStore","combineReducers","book","reducers","applyMiddleware","run","rootSaga","initialState","users","isFetching","isError","state","action","type","GET_USERS","GET_USERS_SUCCESS","GET_USERS_ERROR","DISPLAY_PAGE","UPDATE_SETTINGS","getUserApiUrl","page","join","a","axios","get","then","response","data","results","getUsers","getDisplayedPage","getLoadedPage","serviceCountries","select","put","call","UserService","all","takeLeading","displayPage","updateSettings","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.26218b25.chunk.js","sourcesContent":["export type Countries = string[];\n\n/**\n * Countries from which users are fetched\n */\nexport const countries: Countries = [\"ch\", \"es\", \"fr\", \"gb\"];\n\n/**\n * Max page size fetched by one api call\n */\nexport const batchSize = 50;\n\n/**\n * Max catalogue size. No more users are feched after meeting this limit\n */\nexport const catalogueSize = 1000;\n\nexport default {\n  countries,\n  batchSize,\n  catalogueSize,\n};\n","import { Countries as CountriesConfig } from \"../../config\";\nimport { Countries as CountriesState, User } from \"./types\";\nimport { Countries as CountriesService } from \"../../services/userService\";\n\n/**\n * Maps config to redux store\n * \n * @param countries - countries configuration\n * @returns countries to be saved in redux store\n */\nexport const mapConfigToState = (countries: CountriesConfig) => {\n  const stateCountries: CountriesState = {};\n  return countries.reduce((acc, country) => {\n    acc[country] = true;\n    return acc;\n  }, stateCountries);\n};\n\n/**\n * Appends new page to current users list.\n * If `reset` is `true` - new page replaces current list,\n * \n * @param stateUsers - current users list\n * @param incomingUsers - new page\n * @param reset - if `true` new page replaces current list\n * @returns updated users list with new page\n */\nexport const appendUsersPage = (\n  stateUsers: User[][],\n  incomingUsers: User[],\n  reset?: boolean\n) => {\n  if (!incomingUsers.length && !reset) {\n    return stateUsers;\n  }\n  return reset ? [incomingUsers] : [...stateUsers, incomingUsers];\n};\n\n/**\n * Generated number of next page to be displayed based on\n * curent displayed and loaded pages.\n * \n * @param loadedPage - number of last loaded page\n * @param displayedPage - currently displayed page\n * @param reset - if `true` returned page is `1`\n * @returns page number to be displayed\n */\nexport const getNextDisplayedPage = (\n  loadedPage: number,\n  displayedPage: number,\n  reset?: boolean\n) => {\n  if (reset) {\n    return 1;\n  }\n\n  return displayedPage <= loadedPage ? displayedPage + 1 : displayedPage;\n};\n\n/**\n * Maps countries list from Redux store to api service\n * \n * @param countries - countries from redux store\n * @returns countries used in api service\n */\nexport const mapReduxToServiceCountries = (\n  countries: CountriesState\n): CountriesService => {\n  const serviceCountries: string[] = [];\n  return Object.entries(countries).reduce((acc, [country, isSelected]) => {\n    isSelected && acc.push(country);\n    return acc;\n  }, serviceCountries);\n};\n\n/**\n * Returns number of next page to be fetched from api service\n * \n * @param currentLoadedPage - number of last page fetched\n * @param displayedPage - number of currently displayed page\n * @param reset - if `true` next loaded page is `1`\n * @returns number of page to be fetched from api\n */\nexport const getNextLoadedPage = (\n  currentLoadedPage: number,\n  displayedPage: number,\n  reset?: boolean\n) => {\n  if (reset) {\n    return 1;\n  }\n\n  return currentLoadedPage <= displayedPage\n    ? currentLoadedPage + 1\n    : currentLoadedPage;\n};\n\n/**\n * Checks if number of page to be loaded does not exeed catalogue size\n * and follows current page.\n * \n * @param nextLoadedPage \n * @param currentLoadedPage \n * @param maxPage - catalogue max size\n * @returns `true` if page number is valid. `false` otherwise.\n */\nexport const isNextLoadedPageValid = (\n  nextLoadedPage: number,\n  currentLoadedPage: number,\n  maxPage: number\n) =>\n  (nextLoadedPage === 1 || nextLoadedPage === currentLoadedPage + 1) &&\n  nextLoadedPage <= maxPage;\n","import Loader from './Loader';\n\nexport default Loader;","/**\n * Defines the {@link Loader} React component.\n * @module\n */\n\nimport React from \"react\";\n\nimport \"./Loader.scss\";\n\n/**\n * Loader displayed when lazy modules are fetched\n *\n * @returns Loader component\n */\nexport const Loader: React.FC = () => (\n  <div className=\"loader-box\">\n    Loading...\n  </div>\n);\n\nexport default Loader;\n","/**\n * Defines the {@link AppRouter} React router.\n * @module\n */\n\nimport React from \"react\";\nimport { BrowserRouter, Switch, Route, Redirect } from \"react-router-dom\";\nimport { batchSize, catalogueSize } from \"../config\";\nimport Loader from '../containers/Loader';\n\nconst AddressBook = React.lazy(() => import(\"../containers/AddressBook\"));\nconst Settings = React.lazy(() => import(\"../containers/Settings\"));\n\nexport const paths: { [key: string]: string } = {\n  main: \"/\",\n  settings: \"/settings\"\n};\n\n/**\n * Application main router.\n * Uses lazy-loading.\n */\nconst AppRouter: React.FC = () => (\n  <BrowserRouter>\n    <Switch>\n      <React.Suspense fallback={<Loader />}>\n        <Route exact path={paths.main}>\n          <AddressBook maxPage={catalogueSize / batchSize} />\n        </Route>\n        <Route exact path={paths.settings}>\n          <Settings />\n        </Route>\n        <Route path=\"*\">\n          <Redirect to={paths.main} />\n        </Route>\n      </React.Suspense>\n    </Switch>\n  </BrowserRouter>\n);\n\nexport default AppRouter;\n","/**\n * Defines the {@link store} Redux store.\n * @module\n */\n\nimport { createStore, combineReducers, applyMiddleware } from \"redux\";\nimport createSagaMiddleware from \"redux-saga\";\nimport reducers from \"./book/reducers\";\nimport rootSaga from \"./book/sagas\";\nimport { BookState } from \"./book/types\"\n\n/**\n * Expose types from all reducers applciation.\n * Only book in this case.\n */\nexport * from './book/types'\n\nconst sagaMiddleware = createSagaMiddleware();\n\n/**\n * Interface of application store\n */\nexport interface State {\n  book: BookState;\n}\n\n/**\n * Redux store\n */\nconst store = createStore(\n  combineReducers({\n    book: reducers\n  }),\n  applyMiddleware(sagaMiddleware)\n);\n\nsagaMiddleware.run(rootSaga);\n\nexport default store;\n","import { countries } from \"../../config\";\nimport { BookState } from \"./types\";\nimport { ActionTypes, DISPLAY_PAGE } from \"./actions\";\nimport { mapConfigToState, appendUsersPage, getNextDisplayedPage } from \"./utils\";\nimport {\n  GET_USERS,\n  GET_USERS_SUCCESS,\n  GET_USERS_ERROR,\n  UPDATE_SETTINGS\n} from \"./actions\";\n\nexport const initialState: BookState = {\n  users: [],\n  isFetching: false,\n  isError: false,\n  countries: mapConfigToState(countries),\n  displayedPage: 0\n};\n\n/**\n * Book sub-application reducer\n */\nexport default (state = initialState, action: ActionTypes): BookState => {\n  switch (action.type) {\n    case GET_USERS:\n      return {\n        ...state,\n        isFetching: true,\n        isError: false\n      };\n    case GET_USERS_SUCCESS:\n      return {\n        ...state,\n        users: appendUsersPage(state.users, action.users, action.reset),\n        isFetching: false,\n        isError: false\n      };\n    case GET_USERS_ERROR:\n      return {\n        ...state,\n        isFetching: false,\n        isError: true\n      };\n    case DISPLAY_PAGE:\n      return {\n        ...state,\n        displayedPage: getNextDisplayedPage(\n          state.users.length,\n          state.displayedPage,\n          action.reset\n        )\n      };\n    case UPDATE_SETTINGS:\n      return {\n        ...state,\n        countries: action.countries\n      };\n    default:\n      return state;\n  }\n};\n","/**\n * Provides calls to APIs\n * @module\n */\n\nimport axios from \"axios\";\nimport { batchSize } from \"../config\";\n\ninterface Info {\n  seed: string;\n  results: number;\n  page: number;\n  version: string;\n}\n\nexport interface User {\n  name: {\n    title: string;\n    first: string;\n    last: string;\n  };\n  location: {\n    street: {\n      number: number;\n      name: string;\n    };\n    city: string;\n    state: string;\n    country: string;\n    postcode: number | string;\n    coordinates: {\n      latitude: string;\n      longitude: string;\n    };\n    timezone: {\n      offset: string;\n      description: string;\n    };\n  };\n  email: string;\n  login: {\n    uuid: string;\n    username: string;\n    password: string;\n    salt: string;\n    md5: string;\n    sha1: string;\n    sha256: string;\n  };\n  phone: string;\n  cell: string;\n  picture: {\n    large: string;\n    medium: string;\n    thumbnail: string;\n  };\n}\n\ninterface UserApiResponse {\n  results: User[];\n  info?: Info;\n}\n\nexport type Countries = string[];\n\nconst host = \"https://randomuser.me/api/\";\n\n/**\n * Generates url to get users from specified page and countries\n * \n * @param countries - countries from config\n * @param page - page url parameter\n * @returns users url for page\n */\nconst getUserApiUrl = (countries: Countries, page: number) =>\n  `${host}?page=${page}&results=${batchSize}&seed=sherpany&nat=${countries.join(\n    \",\"\n  )}&inc=picture,name,email,login,location,phone,cell`;\n\n/**\n * Calls users api and returns a list of them\n * \n * @param countries - countries from config\n * @param page - page url parameter\n * @returns users list\n */\nexport async function getUsers(\n  countries: Countries,\n  page: number\n): Promise<UserApiResponse | []> {\n  if (countries.length === 0) {\n    return [];\n  }\n\n  return axios.get(getUserApiUrl(countries, page)).then(response => {\n    return response.data.results;\n  });\n}\n\nexport default {\n  getUsers\n};\n","import { State } from \"../store\";\n\n/**\n * @param state - application state\n * @returns number of currently displayed page\n */\nexport const getDisplayedPage = (state: State) => state.book.displayedPage;\n\n/**\n * \n * @param state - application state\n * @returns number of last fetched page\n */\nexport const getLoadedPage = (state: State) => state.book.users.length;\n","import { SagaIterator } from \"redux-saga\";\nimport { takeLeading, put, all, call, select } from \"redux-saga/effects\";\nimport UserService, { User } from \"../../services/userService\";\nimport { batchSize, catalogueSize } from \"../../config\";\nimport { GetUsersAction } from \"./actions\";\nimport { getDisplayedPage, getLoadedPage } from \"./selectors\";\nimport {\n  mapReduxToServiceCountries,\n  getNextLoadedPage,\n  isNextLoadedPageValid\n} from \"./utils\";\nimport { GET_USERS, GET_USERS_SUCCESS, GET_USERS_ERROR } from \"./actions\";\n\n/**\n * Saga responsible for calculating next page to fetch and deciding\n * if api call should be performed.\n * \n * @param action - getUsersAction\n */\nexport function* getUsers(action: GetUsersAction): SagaIterator {\n  const serviceCountries = mapReduxToServiceCountries(action.countries);\n\n  const displayedPage = yield select(getDisplayedPage);\n  const currentLoadedPage = yield select(getLoadedPage);\n  const maxPage = catalogueSize / batchSize;\n\n  const nextLoadedPage = getNextLoadedPage(\n    currentLoadedPage,\n    displayedPage,\n    action.reset\n  );\n\n  if (action.reset) {\n    yield put({\n      type: GET_USERS_SUCCESS,\n      users: [],\n      reset: action.reset\n    });\n  }\n\n  if (isNextLoadedPageValid(nextLoadedPage, currentLoadedPage, maxPage)) {\n    try {\n      const users: User[] = yield call(\n        UserService.getUsers,\n        serviceCountries,\n        nextLoadedPage\n      );\n      yield put({\n        type: GET_USERS_SUCCESS,\n        users,\n        reset: action.reset\n      });\n    } catch (err) {\n      yield put({\n        type: GET_USERS_ERROR\n      });\n    }\n  } else {\n    yield put({\n      type: GET_USERS_SUCCESS,\n      users: [],\n      reset: action.reset\n    });\n  }\n}\n\nexport default function* rootSaga() {\n  yield all([takeLeading(GET_USERS, getUsers)]);\n}\n","import { User, Countries } from \"./types\";\n\nexport const GET_USERS = \"GET_USERS\";\nexport const GET_USERS_SUCCESS = \"GET_USERS_SUCCESS\";\nexport const GET_USERS_ERROR = \"GET_USERS_ERROR\";\nexport const DISPLAY_PAGE = \"DISPLAY_PAGE\";\nexport const UPDATE_SETTINGS = \"UPDATE_SETTINGS\";\n\nexport interface GetUsersAction {\n  type: typeof GET_USERS;\n  countries: Countries;\n  reset?: boolean;\n}\n\nexport interface GetUsersSuccessAction {\n  type: typeof GET_USERS_SUCCESS;\n  users: User[];\n  reset?: boolean;\n}\n\nexport interface GetUsersErrorAction {\n  type: typeof GET_USERS_ERROR;\n}\n\nexport interface DisplayPageAction {\n  type: typeof DISPLAY_PAGE;\n  reset?: boolean;\n}\n\nexport interface UpdateSettingsAction {\n  type: typeof UPDATE_SETTINGS;\n  countries: Countries;\n}\n\nexport type ActionTypes =\n  | GetUsersAction\n  | GetUsersSuccessAction\n  | GetUsersErrorAction\n  | DisplayPageAction\n  | UpdateSettingsAction;\n\n/**\n * Initializes fetching users page\n * \n * @param countries - countries from which users should be fetched\n * @param reset - if `true` users are fetched from page nr `1`\n */\nexport const getUsers = (\n  countries: GetUsersAction[\"countries\"],\n  reset?: GetUsersAction[\"reset\"]\n): GetUsersAction => ({\n  type: GET_USERS,\n  countries,\n  reset\n});\n\n/**\n * Initializes applying fetched users to current ones\n * \n * @param users - users fetched from api service\n * @param reset - if `true` current users will be replaced by incomming ones\n */\nexport const getUsersSuccess = (\n  users: GetUsersSuccessAction[\"users\"],\n  reset?: GetUsersSuccessAction[\"reset\"]\n): GetUsersSuccessAction => ({\n  type: GET_USERS_SUCCESS,\n  users,\n  reset\n});\n\n/**\n * Initializes setting error flag\n */\nexport const getUsersError = (): GetUsersErrorAction => ({\n  type: GET_USERS_ERROR\n});\n\n/**\n * Initializes updating page number to be displayed\n * @param reset - if `true` page with nr `1` will be displayed\n */\nexport const displayPage = (reset?: DisplayPageAction['reset']): DisplayPageAction => ({\n  type: DISPLAY_PAGE,\n  reset,\n});\n\n/**\n * Initializes settings application in book Redux store\n * @param countries - countries settings to be applied\n */\nexport const updateSettings = (\n  countries: UpdateSettingsAction[\"countries\"]\n): UpdateSettingsAction => ({\n  type: UPDATE_SETTINGS,\n  countries\n});\n","import App from \"./App\";\n\nexport default App;\n","/**\n * Defines the {@link App} React component.\n * @module\n */\n\nimport React from \"react\";\nimport { Provider } from \"react-redux\";\nimport store from \"../../redux/store\";\nimport Router from \"../../router\";\nimport \"./App.scss\";\n\n/**\n * Application wrapper component\n *\n * @returns App component\n */\nexport const App: React.FC = () => (\n  <Provider store={store}>\n    <Router />\n  </Provider>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './containers/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}